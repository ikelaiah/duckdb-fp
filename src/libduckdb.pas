unit libDuckDB;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
{$IFDEF WINDOWS}
  DuckDB = 'duckdb.dll';
{$ELSE}
  {$IFDEF DARWIN}
    DuckDB = 'libduckdb.dylib';
  {$ELSE}
    DuckDB = 'libduckdb.so';
  {$ENDIF}
{$ENDIF}
  _PU = '';

const
  { TODO : Macro refers to system symbol "__declspec": }
  (* DUCKDB_API __declspec ( dllimport ) *)
  DUCKDB_API_0_3_1 = 1;
  DUCKDB_API_0_3_2 = 2;
  DUCKDB_API_LATEST = DUCKDB_API_0_3_2;
  DUCKDB_API_VERSION = DUCKDB_API_LATEST;

type
  // Forward declarations
  PPUTF8Char = ^PUTF8Char;
  PUInt64 = ^UInt64;
  Pduckdb_date = ^duckdb_date;
  Pduckdb_date_struct = ^duckdb_date_struct;
  Pduckdb_time = ^duckdb_time;
  Pduckdb_time_struct = ^duckdb_time_struct;
  Pduckdb_time_tz = ^duckdb_time_tz;
  Pduckdb_time_tz_struct = ^duckdb_time_tz_struct;
  Pduckdb_timestamp = ^duckdb_timestamp;
  Pduckdb_timestamp_struct = ^duckdb_timestamp_struct;
  Pduckdb_interval = ^duckdb_interval;
  Pduckdb_hugeint = ^duckdb_hugeint;
  Pduckdb_uhugeint = ^duckdb_uhugeint;
  Pduckdb_decimal = ^duckdb_decimal;
  Pduckdb_query_progress_type = ^duckdb_query_progress_type;
  Pduckdb_string_t = ^duckdb_string_t;
  Pduckdb_list_entry = ^duckdb_list_entry;
  Pduckdb_column = ^duckdb_column;
  P_duckdb_vector = ^_duckdb_vector;
  Pduckdb_string = ^duckdb_string;
  Pduckdb_blob = ^duckdb_blob;
  Pduckdb_result = ^duckdb_result;
  P_duckdb_database = ^_duckdb_database;
  P_duckdb_connection = ^_duckdb_connection;
  P_duckdb_prepared_statement = ^_duckdb_prepared_statement;
  P_duckdb_extracted_statements = ^_duckdb_extracted_statements;
  P_duckdb_pending_result = ^_duckdb_pending_result;
  P_duckdb_appender = ^_duckdb_appender;
  P_duckdb_config = ^_duckdb_config;
  P_duckdb_logical_type = ^_duckdb_logical_type;
  P_duckdb_data_chunk = ^_duckdb_data_chunk;
  P_duckdb_value = ^_duckdb_value;
  P_duckdb_arrow = ^_duckdb_arrow;
  P_duckdb_arrow_stream = ^_duckdb_arrow_stream;
  P_duckdb_arrow_schema = ^_duckdb_arrow_schema;
  P_duckdb_arrow_array = ^_duckdb_arrow_array;

  //! An enum over DuckDB's internal types.
  DUCKDB_TYPE = (
    DUCKDB_TYPE_INVALID = 0,
    DUCKDB_TYPE_BOOLEAN = 1,
    DUCKDB_TYPE_TINYINT = 2,
    DUCKDB_TYPE_SMALLINT = 3,
    DUCKDB_TYPE_INTEGER = 4,
    DUCKDB_TYPE_BIGINT = 5,
    DUCKDB_TYPE_UTINYINT = 6,
    DUCKDB_TYPE_USMALLINT = 7,
    DUCKDB_TYPE_UINTEGER = 8,
    DUCKDB_TYPE_UBIGINT = 9,
    DUCKDB_TYPE_FLOAT = 10,
    DUCKDB_TYPE_DOUBLE = 11,
    DUCKDB_TYPE_TIMESTAMP = 12,
    DUCKDB_TYPE_DATE = 13,
    DUCKDB_TYPE_TIME = 14,
    DUCKDB_TYPE_INTERVAL = 15,
    DUCKDB_TYPE_HUGEINT = 16,
    DUCKDB_TYPE_VARCHAR = 17,
    DUCKDB_TYPE_BLOB = 18,
    DUCKDB_TYPE_DECIMAL = 19,
    DUCKDB_TYPE_TIMESTAMP_S = 20,
    DUCKDB_TYPE_TIMESTAMP_MS = 21,
    DUCKDB_TYPE_TIMESTAMP_NS = 22,
    DUCKDB_TYPE_ENUM = 23,
    DUCKDB_TYPE_LIST = 24,
    DUCKDB_TYPE_STRUCT = 25,
    DUCKDB_TYPE_MAP = 26,
    DUCKDB_TYPE_UUID = 27,
    DUCKDB_TYPE_UNION = 28,
    DUCKDB_TYPE_BIT = 29,
    DUCKDB_TYPE_TIME_TZ = 30,
    DUCKDB_TYPE_TIMESTAMP_TZ = 31,
    DUCKDB_TYPE_ARRAY = 32,
    DUCKDB_TYPE_UHUGEINT = 33);
  PDUCKDB_TYPE = ^DUCKDB_TYPE;

  //! An enum over the returned state of different functions.
  duckdb_state = (
    DuckDBSuccess = 0,
    DuckDBError = 1);
  Pduckdb_state = ^duckdb_state;

  //! An enum over the pending state of a pending query result.
  // 2024-11-03. We had a naming conflict. We had both:
  //             1. An enumeration value named DUCKDB_PENDING_ERROR
  //             2. A function named duckdb_pending_error
  //             Even though they have slightly different names (one has underscores, one has 
  //             mixed case), Pascal is case-insensitive by default, so it sees these as 
  //             the same identifier.
  // 2024-11-03. Fixed this by renaming the one of them.
  //             Since the function name needs to match the DLL's exported 
  //             function name, we should rename the enumeration value in this file. 
  duckdb_pending_state = (
    DUCKDB_PENDING_RESULT_READY = 0,
    DUCKDB_PENDING_RESULT_NOT_READY = 1,
    DUCKDB_PENDING_STATE_ERROR = 2,  // Changed from DUCKDB_PENDING_ERROR
    DUCKDB_PENDING_NO_TASKS_AVAILABLE = 3);
  Pduckdb_pending_state = ^duckdb_pending_state;

  //! An enum over DuckDB's different result types.
  duckdb_result_type = (
    DUCKDB_RESULT_TYPE_INVALID = 0,
    DUCKDB_RESULT_TYPE_CHANGED_ROWS = 1,
    DUCKDB_RESULT_TYPE_NOTHING = 2,
    DUCKDB_RESULT_TYPE_QUERY_RESULT = 3);
  Pduckdb_result_type = ^duckdb_result_type;

  //! An enum over DuckDB's different statement types.
  duckdb_statement_type = (
    DUCKDB_STATEMENT_TYPE_INVALID = 0,
    DUCKDB_STATEMENT_TYPE_SELECT = 1,
    DUCKDB_STATEMENT_TYPE_INSERT = 2,
    DUCKDB_STATEMENT_TYPE_UPDATE = 3,
    DUCKDB_STATEMENT_TYPE_EXPLAIN = 4,
    DUCKDB_STATEMENT_TYPE_DELETE = 5,
    DUCKDB_STATEMENT_TYPE_PREPARE = 6,
    DUCKDB_STATEMENT_TYPE_CREATE = 7,
    DUCKDB_STATEMENT_TYPE_EXECUTE = 8,
    DUCKDB_STATEMENT_TYPE_ALTER = 9,
    DUCKDB_STATEMENT_TYPE_TRANSACTION = 10,
    DUCKDB_STATEMENT_TYPE_COPY = 11,
    DUCKDB_STATEMENT_TYPE_ANALYZE = 12,
    DUCKDB_STATEMENT_TYPE_VARIABLE_SET = 13,
    DUCKDB_STATEMENT_TYPE_CREATE_FUNC = 14,
    DUCKDB_STATEMENT_TYPE_DROP = 15,
    DUCKDB_STATEMENT_TYPE_EXPORT = 16,
    DUCKDB_STATEMENT_TYPE_PRAGMA = 17,
    DUCKDB_STATEMENT_TYPE_VACUUM = 18,
    DUCKDB_STATEMENT_TYPE_CALL = 19,
    DUCKDB_STATEMENT_TYPE_SET = 20,
    DUCKDB_STATEMENT_TYPE_LOAD = 21,
    DUCKDB_STATEMENT_TYPE_RELATION = 22,
    DUCKDB_STATEMENT_TYPE_EXTENSION = 23,
    DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN = 24,
    DUCKDB_STATEMENT_TYPE_ATTACH = 25,
    DUCKDB_STATEMENT_TYPE_DETACH = 26,
    DUCKDB_STATEMENT_TYPE_MULTI = 27);
  Pduckdb_statement_type = ^duckdb_statement_type;
  //! DuckDB's index type.
  idx_t = UInt64;
  Pidx_t = ^idx_t;

  //! The callback that will be called to destroy data, e.g.,
  //! bind data (if any), init data (if any), extra data for replacement scans (if any)
  duckdb_delete_callback_t = procedure(data: Pointer); cdecl;
  //! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`.
  duckdb_task_state = Pointer;

  //! Days are stored as days since 1970-01-01
  //! Use the duckdb_from_date/duckdb_to_date function to extract individual information
  duckdb_date = record
    days: Int32;
  end;

  duckdb_date_struct = record
    year: Int32;
    month: Int8;
    day: Int8;
  end;

  //! Time is stored as microseconds since 00:00:00
  //! Use the duckdb_from_time/duckdb_to_time function to extract individual information
  duckdb_time = record
    micros: Int64;
  end;

  duckdb_time_struct = record
    hour: Int8;
    min: Int8;
    sec: Int8;
    micros: Int32;
  end;

  //! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset
  duckdb_time_tz = record
    bits: UInt64;
  end;

  duckdb_time_tz_struct = record
    time: duckdb_time_struct;
    offset: Int32;
  end;

  //! Timestamps are stored as microseconds since 1970-01-01
  //! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
  duckdb_timestamp = record
    micros: Int64;
  end;

  duckdb_timestamp_struct = record
    date: duckdb_date_struct;
    time: duckdb_time_struct;
  end;

  duckdb_interval = record
    months: Int32;
    days: Int32;
    micros: Int64;
  end;

  //! Hugeints are composed of a (lower, upper) component
  //! The value of the hugeint is upper * 2^64 + lower
  //! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
  duckdb_hugeint = record
    lower: UInt64;
    upper: Int64;
  end;

  duckdb_uhugeint = record
    lower: UInt64;
    upper: UInt64;
  end;

  //! Decimals are composed of a width and a scale, and are stored in a hugeint
  duckdb_decimal = record
    width: UInt8;
    scale: UInt8;
    value: duckdb_hugeint;
  end;

  //! A type holding information about the query execution progress
  duckdb_query_progress_type = record
    percentage: Double;
    rows_processed: UInt64;
    total_rows_to_process: UInt64;
  end;

  P_anonymous_type_1 = ^_anonymous_type_1;
  _anonymous_type_1 = record
    length: UInt32;
    prefix: array [0..3] of UTF8Char;
    ptr: PUTF8Char;
  end;

  P_anonymous_type_2 = ^_anonymous_type_2;
  _anonymous_type_2 = record
    length: UInt32;
    inlined: array [0..11] of UTF8Char;
  end;

  P_anonymous_type_3 = ^_anonymous_type_3;
  _anonymous_type_3 = record
    case Integer of
      0: (pointer: _anonymous_type_1);
      1: (inlined: _anonymous_type_2);
  end;

  //! The internal representation of a VARCHAR (string_t). If the VARCHAR does not
  //! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster
  //! string comparisons and store a pointer to the remaining characters. This is a non-
  //! owning structure, i.e., it does not have to be freed.
  duckdb_string_t = record
    value: _anonymous_type_3;
  end;

  //! The internal representation of a list metadata entry contains the list's offset in
  //! the child vector, and its length. The parent vector holds these metadata entries,
  //! whereas the child vector holds the data
  duckdb_list_entry = record
    offset: UInt64;
    length: UInt64;
  end;

  //! A column consists of a pointer to its internal data. Don't operate on this type directly.
  //! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,
  //! duckdb_column_type, and duckdb_column_name, which take the result and the column index
  //! as their parameters
  duckdb_column = record
    __deprecated_data: Pointer;
    __deprecated_nullmask: PBoolean;
    __deprecated_type: duckdb_type;
    __deprecated_name: PUTF8Char;
    internal_data: Pointer;
  end;

  //! A vector to a specified column in a data chunk. Lives as long as the
  //! data chunk lives, i.e., must not be destroyed.
  _duckdb_vector = record
    __vctr: Pointer;
  end;

  //! A vector to a specified column in a data chunk. Lives as long as the
  //! data chunk lives, i.e., must not be destroyed.
  duckdb_vector = P_duckdb_vector;

  //! Strings are composed of a char pointer and a size. You must free string.data
  //! with `duckdb_free`.
  duckdb_string = record
    data: PUTF8Char;
    size: idx_t;
  end;

  //! BLOBs are composed of a byte pointer and a size. You must free blob.data
  //! with `duckdb_free`.
  duckdb_blob = record
    data: Pointer;
    size: idx_t;
  end;

  //! A query result consists of a pointer to its internal data.
  //! Must be freed with 'duckdb_destroy_result'.
  duckdb_result = record
    __deprecated_column_count: idx_t;
    __deprecated_row_count: idx_t;
    __deprecated_rows_changed: idx_t;
    __deprecated_columns: Pduckdb_column;
    __deprecated_error_message: PUTF8Char;
    internal_data: Pointer;
  end;

  //! A database object. Should be closed with `duckdb_close`.
  _duckdb_database = record
    __db: Pointer;
  end;

  //! A database object. Should be closed with `duckdb_close`.
  duckdb_database = P_duckdb_database;
  Pduckdb_database = ^duckdb_database;

  //! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.
  _duckdb_connection = record
    __conn: Pointer;
  end;

  //! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.
  duckdb_connection = P_duckdb_connection;
  Pduckdb_connection = ^duckdb_connection;

  //! A prepared statement is a parameterized query that allows you to bind parameters to it.
  //! Must be destroyed with `duckdb_destroy_prepare`.
  _duckdb_prepared_statement = record
    __prep: Pointer;
  end;

  //! A prepared statement is a parameterized query that allows you to bind parameters to it.
  //! Must be destroyed with `duckdb_destroy_prepare`.
  duckdb_prepared_statement = P_duckdb_prepared_statement;
  Pduckdb_prepared_statement = ^duckdb_prepared_statement;

  //! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.
  _duckdb_extracted_statements = record
    __extrac: Pointer;
  end;

  //! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.
  duckdb_extracted_statements = P_duckdb_extracted_statements;
  Pduckdb_extracted_statements = ^duckdb_extracted_statements;

  //! The pending result represents an intermediate structure for a query that is not yet fully executed.
  //! Must be destroyed with `duckdb_destroy_pending`.
  _duckdb_pending_result = record
    __pend: Pointer;
  end;

  //! The pending result represents an intermediate structure for a query that is not yet fully executed.
  //! Must be destroyed with `duckdb_destroy_pending`.
  duckdb_pending_result = P_duckdb_pending_result;
  Pduckdb_pending_result = ^duckdb_pending_result;

  //! The appender enables fast data loading into DuckDB.
  //! Must be destroyed with `duckdb_appender_destroy`.
  _duckdb_appender = record
    __appn: Pointer;
  end;

  //! The appender enables fast data loading into DuckDB.
  //! Must be destroyed with `duckdb_appender_destroy`.
  duckdb_appender = P_duckdb_appender;
  Pduckdb_appender = ^duckdb_appender;

  //! Can be used to provide start-up options for the DuckDB instance.
  //! Must be destroyed with `duckdb_destroy_config`.
  _duckdb_config = record
    __cnfg: Pointer;
  end;

  //! Can be used to provide start-up options for the DuckDB instance.
  //! Must be destroyed with `duckdb_destroy_config`.
  duckdb_config = P_duckdb_config;
  Pduckdb_config = ^duckdb_config;

  //! Holds an internal logical type.
  //! Must be destroyed with `duckdb_destroy_logical_type`.
  _duckdb_logical_type = record
    __lglt: Pointer;
  end;

  //! Holds an internal logical type.
  //! Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type = P_duckdb_logical_type;
  Pduckdb_logical_type = ^duckdb_logical_type;

  //! Contains a data chunk from a duckdb_result.
  //! Must be destroyed with `duckdb_destroy_data_chunk`.
  _duckdb_data_chunk = record
    __dtck: Pointer;
  end;

  //! Contains a data chunk from a duckdb_result.
  //! Must be destroyed with `duckdb_destroy_data_chunk`.
  duckdb_data_chunk = P_duckdb_data_chunk;
  Pduckdb_data_chunk = ^duckdb_data_chunk;

  //! Holds a DuckDB value, which wraps a type.
  //! Must be destroyed with `duckdb_destroy_value`.
  _duckdb_value = record
    __val: Pointer;
  end;

  //! Holds a DuckDB value, which wraps a type.
  //! Must be destroyed with `duckdb_destroy_value`.
  duckdb_value = P_duckdb_value;
  Pduckdb_value = ^duckdb_value;
  //! A table function. Must be destroyed with `duckdb_destroy_table_function`.
  duckdb_table_function = Pointer;
  Pduckdb_table_function = ^duckdb_table_function;
  //! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function.
  duckdb_bind_info = Pointer;
  //! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function.
  duckdb_init_info = Pointer;
  //! Additional function info. When setting this info, it is necessary to pass a destroy-callback function.
  duckdb_function_info = Pointer;

  //! The bind function of the table function.
  duckdb_table_function_bind_t = procedure(info: duckdb_bind_info); cdecl;

  //! The (possibly thread-local) init function of the table function.
  duckdb_table_function_init_t = procedure(info: duckdb_init_info); cdecl;

  //! The main function of the table function.
  duckdb_table_function_t = procedure(info: duckdb_function_info; output: duckdb_data_chunk); cdecl;
  //! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function.
  duckdb_replacement_scan_info = Pointer;

  //! A replacement scan function that can be added to a database.
  duckdb_replacement_callback_t = procedure(info: duckdb_replacement_scan_info; const table_name: PUTF8Char; data: Pointer); cdecl;

  //! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.
  _duckdb_arrow = record
    __arrw: Pointer;
  end;

  //! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.
  duckdb_arrow = P_duckdb_arrow;
  Pduckdb_arrow = ^duckdb_arrow;

  //! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.
  _duckdb_arrow_stream = record
    __arrwstr: Pointer;
  end;

  //! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.
  duckdb_arrow_stream = P_duckdb_arrow_stream;
  Pduckdb_arrow_stream = ^duckdb_arrow_stream;

  //! Holds an arrow schema. Remember to release the respective ArrowSchema object.
  _duckdb_arrow_schema = record
    __arrs: Pointer;
  end;

  //! Holds an arrow schema. Remember to release the respective ArrowSchema object.
  duckdb_arrow_schema = P_duckdb_arrow_schema;
  Pduckdb_arrow_schema = ^duckdb_arrow_schema;

  //! Holds an arrow array. Remember to release the respective ArrowArray object.
  _duckdb_arrow_array = record
    __arra: Pointer;
  end;

  //! Holds an arrow array. Remember to release the respective ArrowArray object.
  duckdb_arrow_array = P_duckdb_arrow_array;
  Pduckdb_arrow_array = ^duckdb_arrow_array;

(*!
Creates a new database or opens an existing database file stored at the given path.
If no path is given a new in-memory database is created instead.
The instantiated database should be closed with 'duckdb_close'.

 * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
 * out_database: The result database object.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_open(const path: PUTF8Char; out_database: Pduckdb_database): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_open';

(*!
Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.
The instantiated database should be closed with 'duckdb_close'.

 * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
 * out_database: The result database object.
 * config: (Optional) configuration used to start up the database system.
 * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
Note that the error must be freed using `duckdb_free`.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_open_ext(const path: PUTF8Char; out_database: Pduckdb_database; config: duckdb_config; out_error: PPUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_open_ext';

(*!
Closes the specified database and de-allocates all memory allocated for that database.
This should be called after you are done with any database allocated through `duckdb_open` or `duckdb_open_ext`.
Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
Still, it is recommended to always correctly close a database object after you are done with it.

 * database: The database object to shut down.
 *)
procedure duckdb_close(database: Pduckdb_database); cdecl;
  external DuckDB name _PU + 'duckdb_close';

(*!
Opens a connection to a database. Connections are required to query the database, and store transactional state
associated with the connection.
The instantiated connection should be closed using 'duckdb_disconnect'.

 * database: The database file to connect to.
 * out_connection: The result connection object.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_connect(database: duckdb_database; out_connection: Pduckdb_connection): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_connect';

(*!
Interrupt running query

 * connection: The connection to interrupt
 *)
procedure duckdb_interrupt(connection: duckdb_connection); cdecl;
  external DuckDB name _PU + 'duckdb_interrupt';

(*!
Get progress of the running query

 * connection: The working connection
 * returns: -1 if no progress or a percentage of the progress
 *)
function duckdb_query_progress(connection: duckdb_connection): duckdb_query_progress_type; cdecl;
  external DuckDB name _PU + 'duckdb_query_progress';

(*!
Closes the specified connection and de-allocates all memory allocated for that connection.

 * connection: The connection to close.
 *)
procedure duckdb_disconnect(connection: Pduckdb_connection); cdecl;
  external DuckDB name _PU + 'duckdb_disconnect';

(*!
Returns the version of the linked DuckDB, with a version postfix for dev versions

Usually used for developing C extensions that must return this for a compatibility check.
 *)
function duckdb_library_version(): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_library_version';

(*!
Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
through `duckdb_open_ext`.
The duckdb_config must be destroyed using 'duckdb_destroy_config'

This will always succeed unless there is a malloc failure.

 * out_config: The result configuration object.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_create_config(out_config: Pduckdb_config): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_create_config';

(*!
This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.

This should not be called in a loop as it internally loops over all the options.

 * returns: The amount of config options available.
 *)
function duckdb_config_count(): NativeUInt; cdecl;
  external DuckDB name _PU + 'duckdb_config_count';

(*!
Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).

The result name or description MUST NOT be freed.

 * index: The index of the configuration option (between 0 and `duckdb_config_count`)
 * out_name: A name of the configuration flag.
 * out_description: A description of the configuration flag.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_get_config_flag(index: NativeUInt; out_name: PPUTF8Char; out_description: PPUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_get_config_flag';

(*!
Sets the specified option for the specified configuration. The configuration option is indicated by name.
To obtain a list of config options, see `duckdb_get_config_flag`.

In the source code, configuration options are defined in `config.cpp`.

This can fail if either the name is invalid, or if the value provided for the option is invalid.

 * duckdb_config: The configuration object to set the option on.
 * name: The name of the configuration flag to set.
 * option: The value to set the configuration flag to.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_set_config(config: duckdb_config; const name: PUTF8Char; const option: PUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_set_config';

(*!
Destroys the specified configuration object and de-allocates all memory allocated for the object.

 * config: The configuration object to destroy.
 *)
procedure duckdb_destroy_config(config: Pduckdb_config); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_config';

(*!
Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
`duckdb_result_error`.

Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
query fails, otherwise the error stored within the result will not be freed correctly.

 * connection: The connection to perform the query in.
 * query: The SQL query to run.
 * out_result: The query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_query(connection: duckdb_connection; const query: PUTF8Char; out_result: Pduckdb_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_query';

(*!
Closes the result and de-allocates all memory allocated for that connection.

 * result: The result to destroy.
 *)
procedure duckdb_destroy_result(result: Pduckdb_result); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_result';

(*!
Returns the column name of the specified column. The result should not need to be freed; the column names will
automatically be destroyed when the result is destroyed.

Returns `NULL` if the column is out of range.

 * result: The result object to fetch the column name from.
 * col: The column index.
 * returns: The column name of the specified column.
 *)
function duckdb_column_name(result: Pduckdb_result; col: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_column_name';

(*!
Returns the column type of the specified column.

Returns `DUCKDB_TYPE_INVALID` if the column is out of range.

 * result: The result object to fetch the column type from.
 * col: The column index.
 * returns: The column type of the specified column.
 *)
function duckdb_column_type(result: Pduckdb_result; col: idx_t): duckdb_type; cdecl;
  external DuckDB name _PU + 'duckdb_column_type';

(*!
Returns the statement type of the statement that was executed

 * result: The result object to fetch the statement type from.
 * returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
 *)
function duckdb_result_statement_type(result: duckdb_result): duckdb_statement_type; cdecl;
  external DuckDB name _PU + 'duckdb_result_statement_type';

(*!
Returns the logical column type of the specified column.

The return type of this call should be destroyed with `duckdb_destroy_logical_type`.

Returns `NULL` if the column is out of range.

 * result: The result object to fetch the column type from.
 * col: The column index.
 * returns: The logical column type of the specified column.
 *)
function duckdb_column_logical_type(result: Pduckdb_result; col: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_column_logical_type';

(*!
Returns the number of columns present in a the result object.

 * result: The result object.
 * returns: The number of columns present in the result object.
 *)
function duckdb_column_count(result: Pduckdb_result): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_column_count';

(*!
Returns the number of rows present in the result object.

 * result: The result object.
 * returns: The number of rows present in the result object.
 *)
function duckdb_row_count(result: Pduckdb_result): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_row_count';

(*!
Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
queries. For other queries the rows_changed will be 0.

 * result: The result object.
 * returns: The number of rows changed.
 *)
function duckdb_rows_changed(result: Pduckdb_result): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_rows_changed';

(*!
 **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.

Returns the data of a specific column of a result in columnar format.

The function returns a dense array which contains the result data. The exact type stored in the array depends on the
corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.

For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
```c
int32_t *data = (int32_t * ) duckdb_column_data(&result, 0);
printf("Data for row %d: %d\n", row, data[row]);
```

 * result: The result object to fetch the column data from.
 * col: The column index.
 * returns: The column data of the specified column.
 *)
function duckdb_column_data(result: Pduckdb_result; col: idx_t): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_column_data';

(*!
 **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.

Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
by `duckdb_column_data` are undefined.

```c
int32_t *data = (int32_t * ) duckdb_column_data(&result, 0);
bool *nullmask = duckdb_nullmask_data(&result, 0);
if (nullmask[row]) {
    printf("Data for row %d: NULL\n", row);
} else {
    printf("Data for row %d: %d\n", row, data[row]);
}
```

 * result: The result object to fetch the nullmask from.
 * col: The column index.
 * returns: The nullmask of the specified column.
 *)
function duckdb_nullmask_data(result: Pduckdb_result; col: idx_t): PBoolean; cdecl;
  external DuckDB name _PU + 'duckdb_nullmask_data';

(*!
Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.

The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.

 * result: The result object to fetch the error from.
 * returns: The error of the result.
 *)
function duckdb_result_error(result: Pduckdb_result): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_result_error';

(*!
Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.

The result must be destroyed with `duckdb_destroy_data_chunk`.

This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
functions. It results in significantly better performance, and should be preferred in newer code-bases.

If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
mixed with the legacy result functions).

Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.

 * result: The result object to fetch the data chunk from.
 * chunk_index: The chunk index to fetch from.
 * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
 *)
function duckdb_result_get_chunk(result: duckdb_result; chunk_index: idx_t): duckdb_data_chunk; cdecl;
  external DuckDB name _PU + 'duckdb_result_get_chunk';

(*!
Checks if the type of the internal result is StreamQueryResult.

 * result: The result object to check.
 * returns: Whether or not the result object is of the type StreamQueryResult
 *)
function duckdb_result_is_streaming(result: duckdb_result): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_result_is_streaming';

(*!
Returns the number of data chunks present in the result.

 * result: The result object
 * returns: Number of data chunks present in the result.
 *)
function duckdb_result_chunk_count(result: duckdb_result): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_result_chunk_count';

(*!
Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error

 * result: The result object
 * returns: The return_type
 *)
function duckdb_result_return_type(result: duckdb_result): duckdb_result_type; cdecl;
  external DuckDB name _PU + 'duckdb_result_return_type';

(*!
 * returns: The boolean value at the specified location, or false if the value cannot be converted.
 *)
function duckdb_value_boolean(result: Pduckdb_result; col: idx_t; row: idx_t): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_value_boolean';

(*!
 * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_int8(result: Pduckdb_result; col: idx_t; row: idx_t): Int8; cdecl;
  external DuckDB name _PU + 'duckdb_value_int8';

(*!
 * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_int16(result: Pduckdb_result; col: idx_t; row: idx_t): Int16; cdecl;
  external DuckDB name _PU + 'duckdb_value_int16';

(*!
 * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_int32(result: Pduckdb_result; col: idx_t; row: idx_t): Int32; cdecl;
  external DuckDB name _PU + 'duckdb_value_int32';

(*!
 * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_int64(result: Pduckdb_result; col: idx_t; row: idx_t): Int64; cdecl;
  external DuckDB name _PU + 'duckdb_value_int64';

(*!
 * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_hugeint(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_hugeint; cdecl;
  external DuckDB name _PU + 'duckdb_value_hugeint';

(*!
 * returns: The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_uhugeint(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_uhugeint; cdecl;
  external DuckDB name _PU + 'duckdb_value_uhugeint';

(*!
 * returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_decimal(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_decimal; cdecl;
  external DuckDB name _PU + 'duckdb_value_decimal';

(*!
 * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_uint8(result: Pduckdb_result; col: idx_t; row: idx_t): UInt8; cdecl;
  external DuckDB name _PU + 'duckdb_value_uint8';

(*!
 * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_uint16(result: Pduckdb_result; col: idx_t; row: idx_t): UInt16; cdecl;
  external DuckDB name _PU + 'duckdb_value_uint16';

(*!
 * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_uint32(result: Pduckdb_result; col: idx_t; row: idx_t): UInt32; cdecl;
  external DuckDB name _PU + 'duckdb_value_uint32';

(*!
 * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_uint64(result: Pduckdb_result; col: idx_t; row: idx_t): UInt64; cdecl;
  external DuckDB name _PU + 'duckdb_value_uint64';

(*!
 * returns: The float value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_float(result: Pduckdb_result; col: idx_t; row: idx_t): Single; cdecl;
  external DuckDB name _PU + 'duckdb_value_float';

(*!
 * returns: The double value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_double(result: Pduckdb_result; col: idx_t; row: idx_t): Double; cdecl;
  external DuckDB name _PU + 'duckdb_value_double';

(*!
 * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_date(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_date; cdecl;
  external DuckDB name _PU + 'duckdb_value_date';

(*!
 * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_time(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_time; cdecl;
  external DuckDB name _PU + 'duckdb_value_time';

(*!
 * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_timestamp(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_timestamp; cdecl;
  external DuckDB name _PU + 'duckdb_value_timestamp';

(*!
 * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
 *)
function duckdb_value_interval(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_interval; cdecl;
  external DuckDB name _PU + 'duckdb_value_interval';

(*!
 * DEPRECATED: use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.
 * returns: The text value at the specified location as a null-terminated string, or nullptr if the value cannot be
converted. The result must be freed with `duckdb_free`.
 *)
function duckdb_value_varchar(result: Pduckdb_result; col: idx_t; row: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_value_varchar';

(*!
 * returns: The string value at the specified location.
 * The resulting field "string.data" must be freed with `duckdb_free.`
 *)
function duckdb_value_string(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_string; cdecl;
  external DuckDB name _PU + 'duckdb_value_string';

(*!
 * DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
null bytes.
 * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
If the column is NOT a VARCHAR column this function will return NULL.

The result must NOT be freed.
 *)
function duckdb_value_varchar_internal(result: Pduckdb_result; col: idx_t; row: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_value_varchar_internal';

(*!
 * DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
null bytes.
 * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
If the column is NOT a VARCHAR column this function will return NULL.

The result must NOT be freed.
 *)
function duckdb_value_string_internal(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_string; cdecl;
  external DuckDB name _PU + 'duckdb_value_string_internal';

(*!
 * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
value cannot be converted. The resulting field "blob.data" must be freed with `duckdb_free.`
 *)
function duckdb_value_blob(result: Pduckdb_result; col: idx_t; row: idx_t): duckdb_blob; cdecl;
  external DuckDB name _PU + 'duckdb_value_blob';

(*!
 * returns: Returns true if the value at the specified index is NULL, and false otherwise.
 *)
function duckdb_value_is_null(result: Pduckdb_result; col: idx_t; row: idx_t): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_value_is_null';

(*!
Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
should be freed using `duckdb_free`.

 * size: The number of bytes to allocate.
 * returns: A pointer to the allocated memory region.
 *)
function duckdb_malloc(size: NativeUInt): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_malloc';

(*!
Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_value_blob`, or
`duckdb_value_string`.

 * ptr: The memory region to de-allocate.
 *)
procedure duckdb_free(ptr: Pointer); cdecl;
  external DuckDB name _PU + 'duckdb_free';

(*!
The internal vector size used by DuckDB.
This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.

 * returns: The vector size.
 *)
function duckdb_vector_size(): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_vector_size';

(*!
Whether or not the duckdb_string_t value is inlined.
This means that the data of the string does not have a separate allocation.

 *)
function duckdb_string_is_inlined(&string: duckdb_string_t): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_string_is_inlined';

(*!
Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).

 * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
 * returns: The `duckdb_date_struct` with the decomposed elements.
 *)
function duckdb_from_date(date: duckdb_date): duckdb_date_struct; cdecl;
  external DuckDB name _PU + 'duckdb_from_date';

(*!
Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).

 * date: The year, month and date stored in a `duckdb_date_struct`.
 * returns: The `duckdb_date` element.
 *)
function duckdb_to_date(date: duckdb_date_struct): duckdb_date; cdecl;
  external DuckDB name _PU + 'duckdb_to_date';

(*!
Test a `duckdb_date` to see if it is a finite value.

 * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
 * returns: True if the date is finite, false if it is Â±infinity.
 *)
function duckdb_is_finite_date(date: duckdb_date): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_is_finite_date';

(*!
Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).

 * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
 * returns: The `duckdb_time_struct` with the decomposed elements.
 *)
function duckdb_from_time(time: duckdb_time): duckdb_time_struct; cdecl;
  external DuckDB name _PU + 'duckdb_from_time';

(*!
Create a `duckdb_time_tz` object from micros and a timezone offset.

 * micros: The microsecond component of the time.
 * offset: The timezone offset component of the time.
 * returns: The `duckdb_time_tz` element.
 *)
function duckdb_create_time_tz(micros: Int64; offset: Int32): duckdb_time_tz; cdecl;
  external DuckDB name _PU + 'duckdb_create_time_tz';

(*!
Decompose a TIME_TZ objects into micros and a timezone offset.

Use `duckdb_from_time` to further decompose the micros into hour, minute, second and microsecond.

 * micros: The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.
 * out_micros: The microsecond component of the time.
 * out_offset: The timezone offset component of the time.
 *)
function duckdb_from_time_tz(micros: duckdb_time_tz): duckdb_time_tz_struct; cdecl;
  external DuckDB name _PU + 'duckdb_from_time_tz';

(*!
Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).

 * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
 * returns: The `duckdb_time` element.
 *)
function duckdb_to_time(time: duckdb_time_struct): duckdb_time; cdecl;
  external DuckDB name _PU + 'duckdb_to_time';

(*!
Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.

 * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
 * returns: The `duckdb_timestamp_struct` with the decomposed elements.
 *)
function duckdb_from_timestamp(ts: duckdb_timestamp): duckdb_timestamp_struct; cdecl;
  external DuckDB name _PU + 'duckdb_from_timestamp';

(*!
Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.

 * ts: The de-composed elements in a `duckdb_timestamp_struct`.
 * returns: The `duckdb_timestamp` element.
 *)
function duckdb_to_timestamp(ts: duckdb_timestamp_struct): duckdb_timestamp; cdecl;
  external DuckDB name _PU + 'duckdb_to_timestamp';

(*!
Test a `duckdb_timestamp` to see if it is a finite value.

 * ts: The timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
 * returns: True if the timestamp is finite, false if it is Â±infinity.
 *)
function duckdb_is_finite_timestamp(ts: duckdb_timestamp): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_is_finite_timestamp';

(*!
Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.

 * val: The hugeint value.
 * returns: The converted `double` element.
 *)
function duckdb_hugeint_to_double(val: duckdb_hugeint): Double; cdecl;
  external DuckDB name _PU + 'duckdb_hugeint_to_double';

(*!
Converts a double value to a duckdb_hugeint object.

If the conversion fails because the double value is too big the result will be 0.

 * val: The double value.
 * returns: The converted `duckdb_hugeint` element.
 *)
function duckdb_double_to_hugeint(val: Double): duckdb_hugeint; cdecl;
  external DuckDB name _PU + 'duckdb_double_to_hugeint';

(*!
Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` column) into a double.

 * val: The uhugeint value.
 * returns: The converted `double` element.
 *)
function duckdb_uhugeint_to_double(val: duckdb_uhugeint): Double; cdecl;
  external DuckDB name _PU + 'duckdb_uhugeint_to_double';

(*!
Converts a double value to a duckdb_uhugeint object.

If the conversion fails because the double value is too big the result will be 0.

 * val: The double value.
 * returns: The converted `duckdb_uhugeint` element.
 *)
function duckdb_double_to_uhugeint(val: Double): duckdb_uhugeint; cdecl;
  external DuckDB name _PU + 'duckdb_double_to_uhugeint';

(*!
Converts a double value to a duckdb_decimal object.

If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.

 * val: The double value.
 * returns: The converted `duckdb_decimal` element.
 *)
function duckdb_double_to_decimal(val: Double; width: UInt8; scale: UInt8): duckdb_decimal; cdecl;
  external DuckDB name _PU + 'duckdb_double_to_decimal';

(*!
Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.

 * val: The decimal value.
 * returns: The converted `double` element.
 *)
function duckdb_decimal_to_double(val: duckdb_decimal): Double; cdecl;
  external DuckDB name _PU + 'duckdb_decimal_to_double';

(*!
Create a prepared statement object from a query.

Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
`duckdb_destroy_prepare`, even if the prepare fails.

If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.

 * connection: The connection object
 * query: The SQL query to prepare
 * out_prepared_statement: The resulting prepared statement object
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_prepare(connection: duckdb_connection; const query: PUTF8Char; out_prepared_statement: Pduckdb_prepared_statement): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_prepare';

(*!
Closes the prepared statement and de-allocates all memory allocated for the statement.

 * prepared_statement: The prepared statement to destroy.
 *)
procedure duckdb_destroy_prepare(prepared_statement: Pduckdb_prepared_statement); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_prepare';

(*!
Returns the error message associated with the given prepared statement.
If the prepared statement has no error message, this returns `nullptr` instead.

The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.

 * prepared_statement: The prepared statement to obtain the error from.
 * returns: The error message, or `nullptr` if there is none.
 *)
function duckdb_prepare_error(prepared_statement: duckdb_prepared_statement): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_prepare_error';

(*!
Returns the number of parameters that can be provided to the given prepared statement.

Returns 0 if the query was not successfully prepared.

 * prepared_statement: The prepared statement to obtain the number of parameters for.
 *)
function duckdb_nparams(prepared_statement: duckdb_prepared_statement): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_nparams';

(*!
Returns the name used to identify the parameter
The returned string should be freed using `duckdb_free`.

Returns NULL if the index is out of range for the provided prepared statement.

 * prepared_statement: The prepared statement for which to get the parameter name from.
 *)
function duckdb_parameter_name(prepared_statement: duckdb_prepared_statement; index: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_parameter_name';

(*!
Returns the parameter type for the parameter at the given index.

Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.

 * prepared_statement: The prepared statement.
 * param_idx: The parameter index.
 * returns: The parameter type
 *)
function duckdb_param_type(prepared_statement: duckdb_prepared_statement; param_idx: idx_t): duckdb_type; cdecl;
  external DuckDB name _PU + 'duckdb_param_type';

(*!
Clear the params bind to the prepared statement.
 *)
function duckdb_clear_bindings(prepared_statement: duckdb_prepared_statement): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_clear_bindings';

(*!
Returns the statement type of the statement to be executed

 * statement: The prepared statement.
 * returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
 *)
function duckdb_prepared_statement_type(statement: duckdb_prepared_statement): duckdb_statement_type; cdecl;
  external DuckDB name _PU + 'duckdb_prepared_statement_type';

(*!
Binds a value to the prepared statement at the specified index.
 *)
function duckdb_bind_value(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_value): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_value';

(*!
Retrieve the index of the parameter for the prepared statement, identified by name
 *)
function duckdb_bind_parameter_index(prepared_statement: duckdb_prepared_statement; param_idx_out: Pidx_t; const name: PUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_parameter_index';

(*!
Binds a bool value to the prepared statement at the specified index.
 *)
function duckdb_bind_boolean(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Boolean): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_boolean';

(*!
Binds an int8_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_int8(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Int8): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_int8';

(*!
Binds an int16_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_int16(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Int16): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_int16';

(*!
Binds an int32_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_int32(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Int32): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_int32';

(*!
Binds an int64_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_int64(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Int64): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_int64';

(*!
Binds a duckdb_hugeint value to the prepared statement at the specified index.
 *)
function duckdb_bind_hugeint(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_hugeint): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_hugeint';

(*!
Binds an duckdb_uhugeint value to the prepared statement at the specified index.
 *)
function duckdb_bind_uhugeint(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_uhugeint): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_uhugeint';

(*!
Binds a duckdb_decimal value to the prepared statement at the specified index.
 *)
function duckdb_bind_decimal(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_decimal): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_decimal';

(*!
Binds an uint8_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_uint8(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: UInt8): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_uint8';

(*!
Binds an uint16_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_uint16(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: UInt16): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_uint16';

(*!
Binds an uint32_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_uint32(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: UInt32): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_uint32';

(*!
Binds an uint64_t value to the prepared statement at the specified index.
 *)
function duckdb_bind_uint64(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: UInt64): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_uint64';

(*!
Binds a float value to the prepared statement at the specified index.
 *)
function duckdb_bind_float(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Single): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_float';

(*!
Binds a double value to the prepared statement at the specified index.
 *)
function duckdb_bind_double(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: Double): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_double';

(*!
Binds a duckdb_date value to the prepared statement at the specified index.
 *)
function duckdb_bind_date(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_date): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_date';

(*!
Binds a duckdb_time value to the prepared statement at the specified index.
 *)
function duckdb_bind_time(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_time): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_time';

(*!
Binds a duckdb_timestamp value to the prepared statement at the specified index.
 *)
function duckdb_bind_timestamp(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_timestamp): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_timestamp';

(*!
Binds a duckdb_interval value to the prepared statement at the specified index.
 *)
function duckdb_bind_interval(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; val: duckdb_interval): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_interval';

(*!
Binds a null-terminated varchar value to the prepared statement at the specified index.
 *)
function duckdb_bind_varchar(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; const val: PUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_varchar';

(*!
Binds a varchar value to the prepared statement at the specified index.
 *)
function duckdb_bind_varchar_length(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; const val: PUTF8Char; length: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_varchar_length';

(*!
Binds a blob value to the prepared statement at the specified index.
 *)
function duckdb_bind_blob(prepared_statement: duckdb_prepared_statement; param_idx: idx_t; const data: Pointer; length: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_blob';

(*!
Binds a NULL value to the prepared statement at the specified index.
 *)
function duckdb_bind_null(prepared_statement: duckdb_prepared_statement; param_idx: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_bind_null';

(*!
Executes the prepared statement with the given bound parameters, and returns a materialized query result.

This method can be called multiple times for each prepared statement, and the parameters can be modified
between calls to this function.

Note that the result must be freed with `duckdb_destroy_result`.

 * prepared_statement: The prepared statement to execute.
 * out_result: The query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_execute_prepared(prepared_statement: duckdb_prepared_statement; out_result: Pduckdb_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_execute_prepared';

(*!
Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.
To determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`

This method can be called multiple times for each prepared statement, and the parameters can be modified
between calls to this function.

Note that the result must be freed with `duckdb_destroy_result`.

 * prepared_statement: The prepared statement to execute.
 * out_result: The query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_execute_prepared_streaming(prepared_statement: duckdb_prepared_statement; out_result: Pduckdb_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_execute_prepared_streaming';

(*!
Extract all statements from a query.
Note that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using
`duckdb_destroy_extracted`, even if no statements were extracted.

If the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.

 * connection: The connection object
 * query: The SQL query to extract
 * out_extracted_statements: The resulting extracted statements object
 * returns: The number of extracted statements or 0 on failure.
 *)
function duckdb_extract_statements(connection: duckdb_connection; const query: PUTF8Char; out_extracted_statements: Pduckdb_extracted_statements): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_extract_statements';

(*!
Prepare an extracted statement.
Note that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using
`duckdb_destroy_prepare`, even if the prepare fails.

If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.

 * connection: The connection object
 * extracted_statements: The extracted statements object
 * index: The index of the extracted statement to prepare
 * out_prepared_statement: The resulting prepared statement object
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_prepare_extracted_statement(connection: duckdb_connection; extracted_statements: duckdb_extracted_statements; index: idx_t; out_prepared_statement: Pduckdb_prepared_statement): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_prepare_extracted_statement';

(*!
Returns the error message contained within the extracted statements.
The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.

 * result: The extracted statements to fetch the error from.
 * returns: The error of the extracted statements.
 *)
function duckdb_extract_statements_error(extracted_statements: duckdb_extracted_statements): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_extract_statements_error';

(*!
De-allocates all memory allocated for the extracted statements.
 * extracted_statements: The extracted statements to destroy.
 *)
procedure duckdb_destroy_extracted(extracted_statements: Pduckdb_extracted_statements); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_extracted';

(*!
Executes the prepared statement with the given bound parameters, and returns a pending result.
The pending result represents an intermediate structure for a query that is not yet fully executed.
The pending result can be used to incrementally execute a query, returning control to the client between tasks.

Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
`duckdb_destroy_pending`, even if this function returns DuckDBError.

 * prepared_statement: The prepared statement to execute.
 * out_result: The pending query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_pending_prepared(prepared_statement: duckdb_prepared_statement; out_result: Pduckdb_pending_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_pending_prepared';

(*!
Executes the prepared statement with the given bound parameters, and returns a pending result.
This pending result will create a streaming duckdb_result when executed.
The pending result represents an intermediate structure for a query that is not yet fully executed.

Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
`duckdb_destroy_pending`, even if this function returns DuckDBError.

 * prepared_statement: The prepared statement to execute.
 * out_result: The pending query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_pending_prepared_streaming(prepared_statement: duckdb_prepared_statement; out_result: Pduckdb_pending_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_pending_prepared_streaming';

(*!
Closes the pending result and de-allocates all memory allocated for the result.

 * pending_result: The pending result to destroy.
 *)
procedure duckdb_destroy_pending(pending_result: Pduckdb_pending_result); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_pending';

(*!
Returns the error message contained within the pending result.

The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.

 * result: The pending result to fetch the error from.
 * returns: The error of the pending result.
 *)
function duckdb_pending_error(pending_result: duckdb_pending_result): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_pending_error';

(*!
Executes a single task within the query, returning whether or not the query is ready.

If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
If this returns DUCKDB_PENDING_STATE_ERROR, an error occurred during execution.

The error message can be obtained by calling duckdb_pending_error on the pending_result.

 * pending_result: The pending result to execute a task within.
 * returns: The state of the pending result after the execution.
 *)
function duckdb_pending_execute_task(pending_result: duckdb_pending_result): duckdb_pending_state; cdecl;
  external DuckDB name _PU + 'duckdb_pending_execute_task';

(*!
If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_check_state function should be called again.
If this returns DUCKDB_PENDING_STATE_ERROR, an error occurred during execution.

The error message can be obtained by calling duckdb_pending_error on the pending_result.

 * pending_result: The pending result.
 * returns: The state of the pending result.
 *)
function duckdb_pending_execute_check_state(pending_result: duckdb_pending_result): duckdb_pending_state; cdecl;
  external DuckDB name _PU + 'duckdb_pending_execute_check_state';

(*!
Fully execute a pending query result, returning the final query result.

If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
Otherwise, all remaining tasks must be executed first.

Note that the result must be freed with `duckdb_destroy_result`.

 * pending_result: The pending result to execute.
 * out_result: The result object.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_execute_pending(pending_result: duckdb_pending_result; out_result: Pduckdb_result): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_execute_pending';

(*!
Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
DUCKDB_PENDING_RESULT_READY, this function will return true.

 * pending_state: The pending state on which to decide whether to finish execution.
 * returns: Boolean indicating pending execution should be considered finished.
 *)
function duckdb_pending_execution_is_finished(pending_state: duckdb_pending_state): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_pending_execution_is_finished';

(*!
Destroys the value and de-allocates all memory allocated for that type.

 * value: The value to destroy.
 *)
procedure duckdb_destroy_value(value: Pduckdb_value); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_value';

(*!
Creates a value from a null-terminated string

 * value: The null-terminated string
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_varchar(const text: PUTF8Char): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_varchar';

(*!
Creates a value from a string

 * value: The text
 * length: The length of the text
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_varchar_length(const text: PUTF8Char; length: idx_t): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_varchar_length';

(*!
Creates a value from an int64

 * value: The bigint value
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_int64(val: Int64): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_int64';

(*!
Creates a struct value from a type and an array of values

 * type: The type of the struct
 * values: The values for the struct fields
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_struct_value(&type: duckdb_logical_type; values: Pduckdb_value): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_struct_value';

(*!
Creates a list value from a type and an array of values of length `value_count`

 * type: The type of the list
 * values: The values for the list
 * value_count: The number of values in the list
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_list_value(&type: duckdb_logical_type; values: Pduckdb_value; value_count: idx_t): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_list_value';

(*!
Creates a array value from a type and an array of values of length `value_count`

 * type: The type of the array
 * values: The values for the array
 * value_count: The number of values in the array
 * returns: The value. This must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_create_array_value(&type: duckdb_logical_type; values: Pduckdb_value; value_count: idx_t): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_create_array_value';

(*!
Obtains a string representation of the given value.
The result must be destroyed with `duckdb_free`.

 * value: The value
 * returns: The string value. This must be destroyed with `duckdb_free`.
 *)
function duckdb_get_varchar(value: duckdb_value): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_get_varchar';

(*!
Obtains an int64 of the given value.

 * value: The value
 * returns: The int64 value, or 0 if no conversion is possible
 *)
function duckdb_get_int64(value: duckdb_value): Int64; cdecl;
  external DuckDB name _PU + 'duckdb_get_int64';

(*!
Creates a `duckdb_logical_type` from a standard primitive type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

This should not be used with `DUCKDB_TYPE_DECIMAL`.

 * type: The primitive type to create.
 * returns: The logical type.
 *)
function duckdb_create_logical_type(&type: duckdb_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_logical_type';

(*!
Returns the alias of a duckdb_logical_type, if one is set, else `NULL`.
The result must be destroyed with `duckdb_free`.

 * type: The logical type to return the alias of
 * returns: The alias or `NULL`
 *)
function duckdb_logical_type_get_alias(&type: duckdb_logical_type): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_logical_type_get_alias';

(*!
Creates a list type from its child type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * type: The child type of list type to create.
 * returns: The logical type.
 *)
function duckdb_create_list_type(&type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_list_type';

(*!
Creates a array type from its child type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * type: The child type of array type to create.
 * array_size: The number of elements in the array.
 * returns: The logical type.
 *)
function duckdb_create_array_type(&type: duckdb_logical_type; array_size: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_array_type';

(*!
Creates a map type from its key type and value type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * type: The key type and value type of map type to create.
 * returns: The logical type.
 *)
function duckdb_create_map_type(key_type: duckdb_logical_type; value_type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_map_type';

(*!
Creates a UNION type from the passed types array.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * types: The array of types that the union should consist of.
 * type_amount: The size of the types array.
 * returns: The logical type.
 *)
function duckdb_create_union_type(member_types: Pduckdb_logical_type; member_names: PPUTF8Char; member_count: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_union_type';

(*!
Creates a STRUCT type from the passed member name and type arrays.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * member_types: The array of types that the struct should consist of.
 * member_names: The array of names that the struct should consist of.
 * member_count: The number of members that were specified for both arrays.
 * returns: The logical type.
 *)
function duckdb_create_struct_type(member_types: Pduckdb_logical_type; member_names: PPUTF8Char; member_count: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_struct_type';

(*!
Creates an ENUM type from the passed member name array.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * enum_name: The name of the enum.
 * member_names: The array of names that the enum should consist of.
 * member_count: The number of elements that were specified in the array.
 * returns: The logical type.
 *)
function duckdb_create_enum_type(member_names: PPUTF8Char; member_count: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_enum_type';

(*!
Creates a `duckdb_logical_type` of type decimal with the specified width and scale.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * width: The width of the decimal type
 * scale: The scale of the decimal type
 * returns: The logical type.
 *)
function duckdb_create_decimal_type(width: UInt8; scale: UInt8): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_create_decimal_type';

(*!
Retrieves the enum type class of a `duckdb_logical_type`.

 * type: The logical type object
 * returns: The type id
 *)
function duckdb_get_type_id(&type: duckdb_logical_type): duckdb_type; cdecl;
  external DuckDB name _PU + 'duckdb_get_type_id';

(*!
Retrieves the width of a decimal type.

 * type: The logical type object
 * returns: The width of the decimal type
 *)
function duckdb_decimal_width(&type: duckdb_logical_type): UInt8; cdecl;
  external DuckDB name _PU + 'duckdb_decimal_width';

(*!
Retrieves the scale of a decimal type.

 * type: The logical type object
 * returns: The scale of the decimal type
 *)
function duckdb_decimal_scale(&type: duckdb_logical_type): UInt8; cdecl;
  external DuckDB name _PU + 'duckdb_decimal_scale';

(*!
Retrieves the internal storage type of a decimal type.

 * type: The logical type object
 * returns: The internal type of the decimal type
 *)
function duckdb_decimal_internal_type(&type: duckdb_logical_type): duckdb_type; cdecl;
  external DuckDB name _PU + 'duckdb_decimal_internal_type';

(*!
Retrieves the internal storage type of an enum type.

 * type: The logical type object
 * returns: The internal type of the enum type
 *)
function duckdb_enum_internal_type(&type: duckdb_logical_type): duckdb_type; cdecl;
  external DuckDB name _PU + 'duckdb_enum_internal_type';

(*!
Retrieves the dictionary size of the enum type.

 * type: The logical type object
 * returns: The dictionary size of the enum type
 *)
function duckdb_enum_dictionary_size(&type: duckdb_logical_type): UInt32; cdecl;
  external DuckDB name _PU + 'duckdb_enum_dictionary_size';

(*!
Retrieves the dictionary value at the specified position from the enum.

The result must be freed with `duckdb_free`.

 * type: The logical type object
 * index: The index in the dictionary
 * returns: The string value of the enum type. Must be freed with `duckdb_free`.
 *)
function duckdb_enum_dictionary_value(&type: duckdb_logical_type; index: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_enum_dictionary_value';

(*!
Retrieves the child type of the given list type.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_list_type_child_type(&type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_list_type_child_type';

(*!
Retrieves the child type of the given array type.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * returns: The child type of the array type. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_array_type_child_type(&type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_array_type_child_type';

(*!
Retrieves the array size of the given array type.

 * type: The logical type object
 * returns: The fixed number of elements the values of this array type can store.
 *)
function duckdb_array_type_array_size(&type: duckdb_logical_type): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_array_type_array_size';

(*!
Retrieves the key type of the given map type.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_map_type_key_type(&type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_map_type_key_type';

(*!
Retrieves the value type of the given map type.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_map_type_value_type(&type: duckdb_logical_type): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_map_type_value_type';

(*!
Returns the number of children of a struct type.

 * type: The logical type object
 * returns: The number of children of a struct type.
 *)
function duckdb_struct_type_child_count(&type: duckdb_logical_type): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_struct_type_child_count';

(*!
Retrieves the name of the struct child.

The result must be freed with `duckdb_free`.

 * type: The logical type object
 * index: The child index
 * returns: The name of the struct type. Must be freed with `duckdb_free`.
 *)
function duckdb_struct_type_child_name(&type: duckdb_logical_type; index: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_struct_type_child_name';

(*!
Retrieves the child type of the given struct type at the specified index.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * index: The child index
 * returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_struct_type_child_type(&type: duckdb_logical_type; index: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_struct_type_child_type';

(*!
Returns the number of members that the union type has.

 * type: The logical type (union) object
 * returns: The number of members of a union type.
 *)
function duckdb_union_type_member_count(&type: duckdb_logical_type): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_union_type_member_count';

(*!
Retrieves the name of the union member.

The result must be freed with `duckdb_free`.

 * type: The logical type object
 * index: The child index
 * returns: The name of the union member. Must be freed with `duckdb_free`.
 *)
function duckdb_union_type_member_name(&type: duckdb_logical_type; index: idx_t): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_union_type_member_name';

(*!
Retrieves the child type of the given union member at the specified index.

The result must be freed with `duckdb_destroy_logical_type`.

 * type: The logical type object
 * index: The child index
 * returns: The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.
 *)
function duckdb_union_type_member_type(&type: duckdb_logical_type; index: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_union_type_member_type';

(*!
Destroys the logical type and de-allocates all memory allocated for that type.

 * type: The logical type to destroy.
 *)
procedure duckdb_destroy_logical_type(&type: Pduckdb_logical_type); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_logical_type';

(*!
Creates an empty DataChunk with the specified set of types.

Note that the result must be destroyed with `duckdb_destroy_data_chunk`.

 * types: An array of types of the data chunk.
 * column_count: The number of columns.
 * returns: The data chunk.
 *)
function duckdb_create_data_chunk(types: Pduckdb_logical_type; column_count: idx_t): duckdb_data_chunk; cdecl;
  external DuckDB name _PU + 'duckdb_create_data_chunk';

(*!
Destroys the data chunk and de-allocates all memory allocated for that chunk.

 * chunk: The data chunk to destroy.
 *)
procedure duckdb_destroy_data_chunk(chunk: Pduckdb_data_chunk); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_data_chunk';

(*!
Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.

 * chunk: The data chunk to reset.
 *)
procedure duckdb_data_chunk_reset(chunk: duckdb_data_chunk); cdecl;
  external DuckDB name _PU + 'duckdb_data_chunk_reset';

(*!
Retrieves the number of columns in a data chunk.

 * chunk: The data chunk to get the data from
 * returns: The number of columns in the data chunk
 *)
function duckdb_data_chunk_get_column_count(chunk: duckdb_data_chunk): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_data_chunk_get_column_count';

(*!
Retrieves the vector at the specified column index in the data chunk.

The pointer to the vector is valid for as long as the chunk is alive.
It does NOT need to be destroyed.

 * chunk: The data chunk to get the data from
 * returns: The vector
 *)
function duckdb_data_chunk_get_vector(chunk: duckdb_data_chunk; col_idx: idx_t): duckdb_vector; cdecl;
  external DuckDB name _PU + 'duckdb_data_chunk_get_vector';

(*!
Retrieves the current number of tuples in a data chunk.

 * chunk: The data chunk to get the data from
 * returns: The number of tuples in the data chunk
 *)
function duckdb_data_chunk_get_size(chunk: duckdb_data_chunk): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_data_chunk_get_size';

(*!
Sets the current number of tuples in a data chunk.

 * chunk: The data chunk to set the size in
 * size: The number of tuples in the data chunk
 *)
procedure duckdb_data_chunk_set_size(chunk: duckdb_data_chunk; size: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_data_chunk_set_size';

(*!
Retrieves the column type of the specified vector.

The result must be destroyed with `duckdb_destroy_logical_type`.

 * vector: The vector get the data from
 * returns: The type of the vector
 *)
function duckdb_vector_get_column_type(vector: duckdb_vector): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_vector_get_column_type';

(*!
Retrieves the data pointer of the vector.

The data pointer can be used to read or write values from the vector.
How to read or write values depends on the type of the vector.

 * vector: The vector to get the data from
 * returns: The data pointer
 *)
function duckdb_vector_get_data(vector: duckdb_vector): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_vector_get_data';

(*!
Retrieves the validity mask pointer of the specified vector.

If all values are valid, this function MIGHT return NULL!

The validity mask is a bitset that signifies null-ness within the data chunk.
It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).

Validity of a specific value can be obtained like this:

idx_t entry_idx = row_idx / 64;
idx_t idx_in_entry = row_idx % 64;
bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);

Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.

 * vector: The vector to get the data from
 * returns: The pointer to the validity mask, or NULL if no validity mask is present
 *)
function duckdb_vector_get_validity(vector: duckdb_vector): PUInt64; cdecl;
  external DuckDB name _PU + 'duckdb_vector_get_validity';

(*!
Ensures the validity mask is writable by allocating it.

After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
This allows null values to be written to the vector, regardless of whether a validity mask was present before.

 * vector: The vector to alter
 *)
procedure duckdb_vector_ensure_validity_writable(vector: duckdb_vector); cdecl;
  external DuckDB name _PU + 'duckdb_vector_ensure_validity_writable';

(*!
Assigns a string element in the vector at the specified location.

 * vector: The vector to alter
 * index: The row position in the vector to assign the string to
 * str: The null-terminated string
 *)
procedure duckdb_vector_assign_string_element(vector: duckdb_vector; index: idx_t; const str: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_vector_assign_string_element';

(*!
Assigns a string element in the vector at the specified location. You may also use this function to assign BLOBs.

 * vector: The vector to alter
 * index: The row position in the vector to assign the string to
 * str: The string
 * str_len: The length of the string (in bytes)
 *)
procedure duckdb_vector_assign_string_element_len(vector: duckdb_vector; index: idx_t; const str: PUTF8Char; str_len: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_vector_assign_string_element_len';

(*!
Retrieves the child vector of a list vector.

The resulting vector is valid as long as the parent vector is valid.

 * vector: The vector
 * returns: The child vector
 *)
function duckdb_list_vector_get_child(vector: duckdb_vector): duckdb_vector; cdecl;
  external DuckDB name _PU + 'duckdb_list_vector_get_child';

(*!
Returns the size of the child vector of the list.

 * vector: The vector
 * returns: The size of the child list
 *)
function duckdb_list_vector_get_size(vector: duckdb_vector): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_list_vector_get_size';

(*!
Sets the total size of the underlying child-vector of a list vector.

 * vector: The list vector.
 * size: The size of the child list.
 * returns: The duckdb state. Returns DuckDBError if the vector is nullptr.
 *)
function duckdb_list_vector_set_size(vector: duckdb_vector; size: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_list_vector_set_size';

(*!
Sets the total capacity of the underlying child-vector of a list.

 * vector: The list vector.
 * required_capacity: the total capacity to reserve.
 * return: The duckdb state. Returns DuckDBError if the vector is nullptr.
 *)
function duckdb_list_vector_reserve(vector: duckdb_vector; required_capacity: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_list_vector_reserve';

(*!
Retrieves the child vector of a struct vector.

The resulting vector is valid as long as the parent vector is valid.

 * vector: The vector
 * index: The child index
 * returns: The child vector
 *)
function duckdb_struct_vector_get_child(vector: duckdb_vector; index: idx_t): duckdb_vector; cdecl;
  external DuckDB name _PU + 'duckdb_struct_vector_get_child';

(*!
Retrieves the child vector of a array vector.

The resulting vector is valid as long as the parent vector is valid.
The resulting vector has the size of the parent vector multiplied by the array size.

 * vector: The vector
 * returns: The child vector
 *)
function duckdb_array_vector_get_child(vector: duckdb_vector): duckdb_vector; cdecl;
  external DuckDB name _PU + 'duckdb_array_vector_get_child';

(*!
Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.

 * validity: The validity mask, as obtained through `duckdb_vector_get_validity`
 * row: The row index
 * returns: true if the row is valid, false otherwise
 *)
function duckdb_validity_row_is_valid(validity: PUInt64; row: idx_t): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_validity_row_is_valid';

(*!
In a validity mask, sets a specific row to either valid or invalid.

Note that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,
to ensure that there is a validity mask to write to.

 * validity: The validity mask, as obtained through `duckdb_vector_get_validity`.
 * row: The row index
 * valid: Whether or not to set the row to valid, or invalid
 *)
procedure duckdb_validity_set_row_validity(validity: PUInt64; row: idx_t; valid: Boolean); cdecl;
  external DuckDB name _PU + 'duckdb_validity_set_row_validity';

(*!
In a validity mask, sets a specific row to invalid.

Equivalent to `duckdb_validity_set_row_validity` with valid set to false.

 * validity: The validity mask
 * row: The row index
 *)
procedure duckdb_validity_set_row_invalid(validity: PUInt64; row: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_validity_set_row_invalid';

(*!
In a validity mask, sets a specific row to valid.

Equivalent to `duckdb_validity_set_row_validity` with valid set to true.

 * validity: The validity mask
 * row: The row index
 *)
procedure duckdb_validity_set_row_valid(validity: PUInt64; row: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_validity_set_row_valid';

(*!
Creates a new empty table function.

The return value should be destroyed with `duckdb_destroy_table_function`.

 * returns: The table function object.
 *)
function duckdb_create_table_function(): duckdb_table_function; cdecl;
  external DuckDB name _PU + 'duckdb_create_table_function';

(*!
Destroys the given table function object.

 * table_function: The table function to destroy
 *)
procedure duckdb_destroy_table_function(table_function: Pduckdb_table_function); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_table_function';

(*!
Sets the name of the given table function.

 * table_function: The table function
 * name: The name of the table function
 *)
procedure duckdb_table_function_set_name(table_function: duckdb_table_function; const name: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_name';

(*!
Adds a parameter to the table function.

 * table_function: The table function
 * type: The type of the parameter to add.
 *)
procedure duckdb_table_function_add_parameter(table_function: duckdb_table_function; &type: duckdb_logical_type); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_add_parameter';

(*!
Adds a named parameter to the table function.

 * table_function: The table function
 * name: The name of the parameter
 * type: The type of the parameter to add.
 *)
procedure duckdb_table_function_add_named_parameter(table_function: duckdb_table_function; const name: PUTF8Char; &type: duckdb_logical_type); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_add_named_parameter';

(*!
Assigns extra information to the table function that can be fetched during binding, etc.

 * table_function: The table function
 * extra_info: The extra information
 * destroy: The callback that will be called to destroy the bind data (if any)
 *)
procedure duckdb_table_function_set_extra_info(table_function: duckdb_table_function; extra_info: Pointer; destroy: duckdb_delete_callback_t); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_extra_info';

(*!
Sets the bind function of the table function.

 * table_function: The table function
 * bind: The bind function
 *)
procedure duckdb_table_function_set_bind(table_function: duckdb_table_function; bind: duckdb_table_function_bind_t); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_bind';

(*!
Sets the init function of the table function.

 * table_function: The table function
 * init: The init function
 *)
procedure duckdb_table_function_set_init(table_function: duckdb_table_function; init: duckdb_table_function_init_t); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_init';

(*!
Sets the thread-local init function of the table function.

 * table_function: The table function
 * init: The init function
 *)
procedure duckdb_table_function_set_local_init(table_function: duckdb_table_function; init: duckdb_table_function_init_t); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_local_init';

(*!
Sets the main function of the table function.

 * table_function: The table function
 * function: The function
 *)
procedure duckdb_table_function_set_function(table_function: duckdb_table_function; &function: duckdb_table_function_t); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_set_function';

(*!
Sets whether or not the given table function supports projection pushdown.

If this is set to true, the system will provide a list of all required columns in the `init` stage through
the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
If this is set to false (the default), the system will expect all columns to be projected.

 * table_function: The table function
 * pushdown: True if the table function supports projection pushdown, false otherwise.
 *)
procedure duckdb_table_function_supports_projection_pushdown(table_function: duckdb_table_function; pushdown: Boolean); cdecl;
  external DuckDB name _PU + 'duckdb_table_function_supports_projection_pushdown';

(*!
Register the table function object within the given connection.

The function requires at least a name, a bind function, an init function and a main function.

If the function is incomplete or a function with this name already exists DuckDBError is returned.

 * con: The connection to register it in.
 * function: The function pointer
 * returns: Whether or not the registration was successful.
 *)
function duckdb_register_table_function(con: duckdb_connection; &function: duckdb_table_function): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_register_table_function';

(*!
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.

 * info: The info object
 * returns: The extra info
 *)
function duckdb_bind_get_extra_info(info: duckdb_bind_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_bind_get_extra_info';

(*!
Adds a result column to the output of the table function.

 * info: The info object
 * name: The name of the column
 * type: The logical type of the column
 *)
procedure duckdb_bind_add_result_column(info: duckdb_bind_info; const name: PUTF8Char; &type: duckdb_logical_type); cdecl;
  external DuckDB name _PU + 'duckdb_bind_add_result_column';

(*!
Retrieves the number of regular (non-named) parameters to the function.

 * info: The info object
 * returns: The number of parameters
 *)
function duckdb_bind_get_parameter_count(info: duckdb_bind_info): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_bind_get_parameter_count';

(*!
Retrieves the parameter at the given index.

The result must be destroyed with `duckdb_destroy_value`.

 * info: The info object
 * index: The index of the parameter to get
 * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_bind_get_parameter(info: duckdb_bind_info; index: idx_t): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_bind_get_parameter';

(*!
Retrieves a named parameter with the given name.

The result must be destroyed with `duckdb_destroy_value`.

 * info: The info object
 * name: The name of the parameter
 * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
 *)
function duckdb_bind_get_named_parameter(info: duckdb_bind_info; const name: PUTF8Char): duckdb_value; cdecl;
  external DuckDB name _PU + 'duckdb_bind_get_named_parameter';

(*!
Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.

 * info: The info object
 * extra_data: The bind data object.
 * destroy: The callback that will be called to destroy the bind data (if any)
 *)
procedure duckdb_bind_set_bind_data(info: duckdb_bind_info; bind_data: Pointer; destroy: duckdb_delete_callback_t); cdecl;
  external DuckDB name _PU + 'duckdb_bind_set_bind_data';

(*!
Sets the cardinality estimate for the table function, used for optimization.

 * info: The bind data object.
 * is_exact: Whether or not the cardinality estimate is exact, or an approximation
 *)
procedure duckdb_bind_set_cardinality(info: duckdb_bind_info; cardinality: idx_t; is_exact: Boolean); cdecl;
  external DuckDB name _PU + 'duckdb_bind_set_cardinality';

(*!
Report that an error has occurred while calling bind.

 * info: The info object
 * error: The error message
 *)
procedure duckdb_bind_set_error(info: duckdb_bind_info; const error: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_bind_set_error';

(*!
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.

 * info: The info object
 * returns: The extra info
 *)
function duckdb_init_get_extra_info(info: duckdb_init_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_init_get_extra_info';

(*!
Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.

Note that the bind data should be considered as read-only.
For tracking state, use the init data instead.

 * info: The info object
 * returns: The bind data object
 *)
function duckdb_init_get_bind_data(info: duckdb_init_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_init_get_bind_data';

(*!
Sets the user-provided init data in the init object. This object can be retrieved again during execution.

 * info: The info object
 * extra_data: The init data object.
 * destroy: The callback that will be called to destroy the init data (if any)
 *)
procedure duckdb_init_set_init_data(info: duckdb_init_info; init_data: Pointer; destroy: duckdb_delete_callback_t); cdecl;
  external DuckDB name _PU + 'duckdb_init_set_init_data';

(*!
Returns the number of projected columns.

This function must be used if projection pushdown is enabled to figure out which columns to emit.

 * info: The info object
 * returns: The number of projected columns.
 *)
function duckdb_init_get_column_count(info: duckdb_init_info): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_init_get_column_count';

(*!
Returns the column index of the projected column at the specified position.

This function must be used if projection pushdown is enabled to figure out which columns to emit.

 * info: The info object
 * column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
 * returns: The column index of the projected column.
 *)
function duckdb_init_get_column_index(info: duckdb_init_info; column_index: idx_t): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_init_get_column_index';

(*!
Sets how many threads can process this table function in parallel (default: 1)

 * info: The info object
 * max_threads: The maximum amount of threads that can process this table function
 *)
procedure duckdb_init_set_max_threads(info: duckdb_init_info; max_threads: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_init_set_max_threads';

(*!
Report that an error has occurred while calling init.

 * info: The info object
 * error: The error message
 *)
procedure duckdb_init_set_error(info: duckdb_init_info; const error: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_init_set_error';

(*!
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.

 * info: The info object
 * returns: The extra info
 *)
function duckdb_function_get_extra_info(info: duckdb_function_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_function_get_extra_info';

(*!
Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.

Note that the bind data should be considered as read-only.
For tracking state, use the init data instead.

 * info: The info object
 * returns: The bind data object
 *)
function duckdb_function_get_bind_data(info: duckdb_function_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_function_get_bind_data';

(*!
Gets the init data set by `duckdb_init_set_init_data` during the init.

 * info: The info object
 * returns: The init data object
 *)
function duckdb_function_get_init_data(info: duckdb_function_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_function_get_init_data';

(*!
Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.

 * info: The info object
 * returns: The init data object
 *)
function duckdb_function_get_local_init_data(info: duckdb_function_info): Pointer; cdecl;
  external DuckDB name _PU + 'duckdb_function_get_local_init_data';

(*!
Report that an error has occurred while executing the function.

 * info: The info object
 * error: The error message
 *)
procedure duckdb_function_set_error(info: duckdb_function_info; const error: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_function_set_error';

(*!
Add a replacement scan definition to the specified database.

 * db: The database object to add the replacement scan to
 * replacement: The replacement scan callback
 * extra_data: Extra data that is passed back into the specified callback
 * delete_callback: The delete callback to call on the extra data, if any
 *)
procedure duckdb_add_replacement_scan(db: duckdb_database; replacement: duckdb_replacement_callback_t; extra_data: Pointer; delete_callback: duckdb_delete_callback_t); cdecl;
  external DuckDB name _PU + 'duckdb_add_replacement_scan';

(*!
Sets the replacement function name. If this function is called in the replacement callback,
the replacement scan is performed. If it is not called, the replacement callback is not performed.

 * info: The info object
 * function_name: The function name to substitute.
 *)
procedure duckdb_replacement_scan_set_function_name(info: duckdb_replacement_scan_info; const function_name: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_replacement_scan_set_function_name';

(*!
Adds a parameter to the replacement scan function.

 * info: The info object
 * parameter: The parameter to add.
 *)
procedure duckdb_replacement_scan_add_parameter(info: duckdb_replacement_scan_info; parameter: duckdb_value); cdecl;
  external DuckDB name _PU + 'duckdb_replacement_scan_add_parameter';

(*!
Report that an error has occurred while executing the replacement scan.

 * info: The info object
 * error: The error message
 *)
procedure duckdb_replacement_scan_set_error(info: duckdb_replacement_scan_info; const error: PUTF8Char); cdecl;
  external DuckDB name _PU + 'duckdb_replacement_scan_set_error';

(*!
Creates an appender object.

Note that the object must be destroyed with `duckdb_appender_destroy`.

 * connection: The connection context to create the appender in.
 * schema: The schema of the table to append to, or `nullptr` for the default schema.
 * table: The table name to append to.
 * out_appender: The resulting appender object.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_appender_create(connection: duckdb_connection; const schema: PUTF8Char; const table: PUTF8Char; out_appender: Pduckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_create';

(*!
Returns the number of columns in the table that belongs to the appender.

 * appender The appender to get the column count from.
 * returns: The number of columns in the table.
 *)
function duckdb_appender_column_count(appender: duckdb_appender): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_appender_column_count';

(*!
Returns the type of the column at the specified index.

Note: The resulting type should be destroyed with `duckdb_destroy_logical_type`.

 * appender The appender to get the column type from.
 * col_idx The index of the column to get the type of.
 * returns: The duckdb_logical_type of the column.
 *)
function duckdb_appender_column_type(appender: duckdb_appender; col_idx: idx_t): duckdb_logical_type; cdecl;
  external DuckDB name _PU + 'duckdb_appender_column_type';

(*!
Returns the error message associated with the given appender.
If the appender has no error message, this returns `nullptr` instead.

The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.

 * appender: The appender to get the error from.
 * returns: The error message, or `nullptr` if there is none.
 *)
function duckdb_appender_error(appender: duckdb_appender): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_appender_error';

(*!
Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
base table.

This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
are done with the appender.

 * appender: The appender to flush.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_appender_flush(appender: duckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_flush';

(*!
Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.

This is generally not necessary. Call `duckdb_appender_destroy` instead.

 * appender: The appender to flush and close.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_appender_close(appender: duckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_close';

(*!
Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
all memory associated with the appender.

 * appender: The appender to flush, close and destroy.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_appender_destroy(appender: Pduckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_destroy';

(*!
A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
 *)
function duckdb_appender_begin_row(appender: duckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_begin_row';

(*!
Finish the current row of appends. After end_row is called, the next row can be appended.

 * appender: The appender.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_appender_end_row(appender: duckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_appender_end_row';

(*!
Append a bool value to the appender.
 *)
function duckdb_append_bool(appender: duckdb_appender; value: Boolean): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_bool';

(*!
Append an int8_t value to the appender.
 *)
function duckdb_append_int8(appender: duckdb_appender; value: Int8): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_int8';

(*!
Append an int16_t value to the appender.
 *)
function duckdb_append_int16(appender: duckdb_appender; value: Int16): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_int16';

(*!
Append an int32_t value to the appender.
 *)
function duckdb_append_int32(appender: duckdb_appender; value: Int32): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_int32';

(*!
Append an int64_t value to the appender.
 *)
function duckdb_append_int64(appender: duckdb_appender; value: Int64): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_int64';

(*!
Append a duckdb_hugeint value to the appender.
 *)
function duckdb_append_hugeint(appender: duckdb_appender; value: duckdb_hugeint): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_hugeint';

(*!
Append a uint8_t value to the appender.
 *)
function duckdb_append_uint8(appender: duckdb_appender; value: UInt8): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_uint8';

(*!
Append a uint16_t value to the appender.
 *)
function duckdb_append_uint16(appender: duckdb_appender; value: UInt16): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_uint16';

(*!
Append a uint32_t value to the appender.
 *)
function duckdb_append_uint32(appender: duckdb_appender; value: UInt32): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_uint32';

(*!
Append a uint64_t value to the appender.
 *)
function duckdb_append_uint64(appender: duckdb_appender; value: UInt64): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_uint64';

(*!
Append a duckdb_uhugeint value to the appender.
 *)
function duckdb_append_uhugeint(appender: duckdb_appender; value: duckdb_uhugeint): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_uhugeint';

(*!
Append a float value to the appender.
 *)
function duckdb_append_float(appender: duckdb_appender; value: Single): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_float';

(*!
Append a double value to the appender.
 *)
function duckdb_append_double(appender: duckdb_appender; value: Double): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_double';

(*!
Append a duckdb_date value to the appender.
 *)
function duckdb_append_date(appender: duckdb_appender; value: duckdb_date): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_date';

(*!
Append a duckdb_time value to the appender.
 *)
function duckdb_append_time(appender: duckdb_appender; value: duckdb_time): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_time';

(*!
Append a duckdb_timestamp value to the appender.
 *)
function duckdb_append_timestamp(appender: duckdb_appender; value: duckdb_timestamp): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_timestamp';

(*!
Append a duckdb_interval value to the appender.
 *)
function duckdb_append_interval(appender: duckdb_appender; value: duckdb_interval): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_interval';

(*!
Append a varchar value to the appender.
 *)
function duckdb_append_varchar(appender: duckdb_appender; const val: PUTF8Char): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_varchar';

(*!
Append a varchar value to the appender.
 *)
function duckdb_append_varchar_length(appender: duckdb_appender; const val: PUTF8Char; length: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_varchar_length';

(*!
Append a blob value to the appender.
 *)
function duckdb_append_blob(appender: duckdb_appender; const data: Pointer; length: idx_t): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_blob';

(*!
Append a NULL value to the appender (of any type).
 *)
function duckdb_append_null(appender: duckdb_appender): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_null';

(*!
Appends a pre-filled data chunk to the specified appender.

The types of the data chunk must exactly match the types of the table, no casting is performed.
If the types do not match or the appender is in an invalid state, DuckDBError is returned.
If the append is successful, DuckDBSuccess is returned.

 * appender: The appender to append to.
 * chunk: The data chunk to append.
 * returns: The return state.
 *)
function duckdb_append_data_chunk(appender: duckdb_appender; chunk: duckdb_data_chunk): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_append_data_chunk';

(*!
Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
`duckdb_query_arrow_error`.

Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
query fails, otherwise the error stored within the result will not be freed correctly.

 * connection: The connection to perform the query in.
 * query: The SQL query to run.
 * out_result: The query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_query_arrow(connection: duckdb_connection; const query: PUTF8Char; out_result: Pduckdb_arrow): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_query_arrow';

(*!
Fetch the internal arrow schema from the arrow result. Remember to call release on the respective
ArrowSchema object.

 * result: The result to fetch the schema from.
 * out_schema: The output schema.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_query_arrow_schema(result: duckdb_arrow; out_schema: Pduckdb_arrow_schema): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_query_arrow_schema';

(*!
Fetch the internal arrow schema from the prepared statement. Remember to call release on the respective
ArrowSchema object.

 * result: The prepared statement to fetch the schema from.
 * out_schema: The output schema.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_prepared_arrow_schema(prepared: duckdb_prepared_statement; out_schema: Pduckdb_arrow_schema): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_prepared_arrow_schema';

(*!
Convert a data chunk into an arrow struct array. Remember to call release on the respective
ArrowArray object.

 * result: The result object the data chunk have been fetched from.
 * chunk: The data chunk to convert.
 * out_array: The output array.
 *)
procedure duckdb_result_arrow_array(result: duckdb_result; chunk: duckdb_data_chunk; out_array: Pduckdb_arrow_array); cdecl;
  external DuckDB name _PU + 'duckdb_result_arrow_array';

(*!
Fetch an internal arrow struct array from the arrow result. Remember to call release on the respective
ArrowArray object.

This function can be called multiple time to get next chunks, which will free the previous out_array.
So consume the out_array before calling this function again.

 * result: The result to fetch the array from.
 * out_array: The output array.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_query_arrow_array(result: duckdb_arrow; out_array: Pduckdb_arrow_array): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_query_arrow_array';

(*!
Returns the number of columns present in the arrow result object.

 * result: The result object.
 * returns: The number of columns present in the result object.
 *)
function duckdb_arrow_column_count(result: duckdb_arrow): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_arrow_column_count';

(*!
Returns the number of rows present in the arrow result object.

 * result: The result object.
 * returns: The number of rows present in the result object.
 *)
function duckdb_arrow_row_count(result: duckdb_arrow): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_arrow_row_count';

(*!
Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.

 * result: The result object.
 * returns: The number of rows changed.
 *)
function duckdb_arrow_rows_changed(result: duckdb_arrow): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_arrow_rows_changed';

(*!
Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
`DuckDBError`.

The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.

 * result: The result object to fetch the error from.
 * returns: The error of the result.
 *)
function duckdb_query_arrow_error(result: duckdb_arrow): PUTF8Char; cdecl;
  external DuckDB name _PU + 'duckdb_query_arrow_error';

(*!
Closes the result and de-allocates all memory allocated for the arrow result.

 * result: The result to destroy.
 *)
procedure duckdb_destroy_arrow(result: Pduckdb_arrow); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_arrow';

(*!
Releases the arrow array stream and de-allocates its memory.

 * stream: The arrow array stream to destroy.
 *)
procedure duckdb_destroy_arrow_stream(stream_p: Pduckdb_arrow_stream); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_arrow_stream';

(*!
Executes the prepared statement with the given bound parameters, and returns an arrow query result.
Note that after running `duckdb_execute_prepared_arrow`, `duckdb_destroy_arrow` must be called on the result object.

 * prepared_statement: The prepared statement to execute.
 * out_result: The query result.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_execute_prepared_arrow(prepared_statement: duckdb_prepared_statement; out_result: Pduckdb_arrow): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_execute_prepared_arrow';

(*!
Scans the Arrow stream and creates a view with the given name.

 * connection: The connection on which to execute the scan.
 * table_name: Name of the temporary view to create.
 * arrow: Arrow stream wrapper.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_arrow_scan(connection: duckdb_connection; const table_name: PUTF8Char; arrow: duckdb_arrow_stream): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_arrow_scan';

(*!
Scans the Arrow array and creates a view with the given name.
Note that after running `duckdb_arrow_array_scan`, `duckdb_destroy_arrow_stream` must be called on the out stream.

 * connection: The connection on which to execute the scan.
 * table_name: Name of the temporary view to create.
 * arrow_schema: Arrow schema wrapper.
 * arrow_array: Arrow array wrapper.
 * out_stream: Output array stream that wraps around the passed schema, for releasing/deleting once done.
 * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
 *)
function duckdb_arrow_array_scan(connection: duckdb_connection; const table_name: PUTF8Char; arrow_schema: duckdb_arrow_schema; arrow_array: duckdb_arrow_array; out_stream: Pduckdb_arrow_stream): duckdb_state; cdecl;
  external DuckDB name _PU + 'duckdb_arrow_array_scan';

(*!
Execute DuckDB tasks on this thread.

Will return after `max_tasks` have been executed, or if there are no more tasks present.

 * database: The database object to execute tasks for
 * max_tasks: The maximum amount of tasks to execute
 *)
procedure duckdb_execute_tasks(database: duckdb_database; max_tasks: idx_t); cdecl;
  external DuckDB name _PU + 'duckdb_execute_tasks';

(*!
Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
`duckdb_finish_execution` is called on the state.

`duckdb_destroy_state` must be called on the result.

 * database: The database object to create the task state for
 * returns: The task state that can be used with duckdb_execute_tasks_state.
 *)
function duckdb_create_task_state(database: duckdb_database): duckdb_task_state; cdecl;
  external DuckDB name _PU + 'duckdb_create_task_state';

(*!
Execute DuckDB tasks on this thread.

The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
Multiple threads can share the same duckdb_task_state.

 * state: The task state of the executor
 *)
procedure duckdb_execute_tasks_state(state: duckdb_task_state); cdecl;
  external DuckDB name _PU + 'duckdb_execute_tasks_state';

(*!
Execute DuckDB tasks on this thread.

The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
max_tasks tasks have been executed or there are no more tasks to be executed.

Multiple threads can share the same duckdb_task_state.

 * state: The task state of the executor
 * max_tasks: The maximum amount of tasks to execute
 * returns: The amount of tasks that have actually been executed
 *)
function duckdb_execute_n_tasks_state(state: duckdb_task_state; max_tasks: idx_t): idx_t; cdecl;
  external DuckDB name _PU + 'duckdb_execute_n_tasks_state';

(*!
Finish execution on a specific task.

 * state: The task state to finish execution
 *)
procedure duckdb_finish_execution(state: duckdb_task_state); cdecl;
  external DuckDB name _PU + 'duckdb_finish_execution';

(*!
Check if the provided duckdb_task_state has finished execution

 * state: The task state to inspect
 * returns: Whether or not duckdb_finish_execution has been called on the task state
 *)
function duckdb_task_state_is_finished(state: duckdb_task_state): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_task_state_is_finished';

(*!
Destroys the task state returned from duckdb_create_task_state.

Note that this should not be called while there is an active duckdb_execute_tasks_state running
on the task state.

 * state: The task state to clean up
 *)
procedure duckdb_destroy_task_state(state: duckdb_task_state); cdecl;
  external DuckDB name _PU + 'duckdb_destroy_task_state';

(*!
Returns true if the execution of the current query is finished.

 * con: The connection on which to check
 *)
function duckdb_execution_is_finished(con: duckdb_connection): Boolean; cdecl;
  external DuckDB name _PU + 'duckdb_execution_is_finished';

(*!
Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
exhausted.

The result must be destroyed with `duckdb_destroy_data_chunk`.

This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'

If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
mixed with the legacy result functions or the materialized result functions).

It is not known beforehand how many chunks will be returned by this result.

 * result: The result object to fetch the data chunk from.
 * returns: The resulting data chunk. Returns `NULL` if the result has an error.
 *)
function duckdb_stream_fetch_chunk(result: duckdb_result): duckdb_data_chunk; cdecl;
  external DuckDB name _PU + 'duckdb_stream_fetch_chunk';

implementation

end.